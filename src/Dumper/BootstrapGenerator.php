<?php

declare(strict_types=1);

namespace PhpPacker\Dumper;

use PhpPacker\Storage\SqliteStorage;
use Psr\Log\LoggerInterface;

class BootstrapGenerator
{
    private SqliteStorage $storage;
    // Removed unused property: logger
    private array $config;

    /**
     * @phpstan-ignore-next-line constructor.unusedParameter
     */
    public function __construct(SqliteStorage $storage, LoggerInterface $logger, array $config = [])
    {
        $this->storage = $storage;
        // Removed: logger assignment
        $this->config = $config;
    }

    public function generate(array $files, string $entryPoint): string
    {
        $bootstrap = $this->getHeader();
        $bootstrap .= $this->getErrorHandler();
        $bootstrap .= $this->getAutoloader($files);
        $bootstrap .= $this->getEnvironmentSetup();
        $bootstrap .= $this->getPackedMarker();
        
        return $bootstrap;
    }

    private function getHeader(): string
    {
        $date = date('Y-m-d H:i:s');
        $version = $this->config['version'] ?? '1.0.0';
        
        return <<<PHP
<?php
/**
 * Generated by php-packer at $date
 * Version: $version
 * DO NOT EDIT THIS FILE MANUALLY
 */

declare(strict_types=1);

namespace {

PHP;
    }

    private function getErrorHandler(): string
    {
        $errorReporting = $this->config['runtime']['error_reporting'] ?? 'E_ALL';
        
        return <<<PHP

    // Error handling setup
    error_reporting($errorReporting);
    set_error_handler(function (\$errno, \$errstr, \$errfile, \$errline) {
        if (error_reporting() & \$errno) {
            throw new ErrorException(\$errstr, 0, \$errno, \$errfile, \$errline);
        }
        return false;
    });

PHP;
    }

    private function getAutoloader(array $files): string
    {
        $classMap = $this->buildClassMap($files);
        $classMapExport = var_export($classMap, true);
        
        return <<<PHP

    // Autoloader
    \$GLOBALS['__PACKED_AUTOLOADER'] = function(\$class) {
        static \$classMap = $classMapExport;
        
        \$class = ltrim(\$class, '\\\\');
        
        if (isset(\$classMap[\$class])) {
            \$file = \$classMap[\$class];
            if (strpos(\$file, '__PACKED_OFFSET__') === 0) {
                \$offset = (int) substr(\$file, 17);
                eval(\$GLOBALS['__PACKED_FILES'][\$offset]);
                return true;
            }
        }
        
        return false;
    };
    
    spl_autoload_register(\$GLOBALS['__PACKED_AUTOLOADER'], true, true);

PHP;
    }

    private function buildClassMap(array $files): array
    {
        $classMap = [];
        
        foreach ($files as $index => $file) {
            $pdo = $this->storage->getPdo();
            $stmt = $pdo->prepare('
                SELECT fqn FROM symbols 
                WHERE file_id = :file_id AND symbol_type IN ("class", "interface", "trait")
            ');
            $stmt->execute([':file_id' => $file['id']]);
            
            while (($symbol = $stmt->fetch()) !== false) {
                $classMap[$symbol['fqn']] = "__PACKED_OFFSET__$index";
            }
        }
        
        return $classMap;
    }

    private function getEnvironmentSetup(): string
    {
        $memoryLimit = $this->config['runtime']['memory_limit'] ?? '256M';
        $timezone = $this->config['runtime']['timezone'] ?? 'UTC';
        
        return <<<PHP

    // Environment setup
    ini_set('memory_limit', '$memoryLimit');
    date_default_timezone_set('$timezone');

PHP;
    }

    private function getPackedMarker(): string
    {
        return <<<PHP

    // Packed marker
    if (!defined('__PACKED__')) {
        define('__PACKED__', true);
        define('__PACKED_TIME__', time());
    }

    // Initialize packed files array
    \$GLOBALS['__PACKED_FILES'] = [];

PHP;
    }

    public function generateEntryPoint(string $entryFile): string
    {
        return <<<PHP

    // Entry point
    (function() {
        require_once '__PACKED_ENTRY__';
    })();

}

PHP;
    }
}